/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * Collect Map API
 * Django backend for Collect Map API - Mountain and Path data management
 * OpenAPI spec version: 1.0.0
 */

import { customFetch } from ".././custom-fetch";
import type {
  PaginatedPathList,
  Path,
  PathsBulkDeleteCreate200,
  PathsBulkDeleteCreate400,
  PathsBulkDeleteCreateParams,
  PathsListParams,
} from ".././models";

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
  T,
>() => T extends Y ? 1 : 2
  ? A
  : B;

type WritableKeys<T> = {
  [P in keyof T]-?: IfEquals<
    { [Q in P]: T[P] },
    { -readonly [Q in P]: T[P] },
    P
  >;
}[keyof T];

// biome-ignore lint/suspicious/noExplicitAny: Generated code from orval, type utilities require any
type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (
  k: infer I,
) => void
  ? I
  : never;
// biome-ignore lint/suspicious/noExplicitAny: Generated code from orval, type utilities require any
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>]
  ? {
      [P in keyof Writable<T>]: T[P] extends object
        ? NonReadonly<NonNullable<T[P]>>
        : T[P];
    }
  : DistributeReadOnlyOverUnions<T>;

/**
 * ÊåáÂÆö„Åï„Çå„ÅüID„ÅÆPath„ÅÆË©≥Á¥∞ÊÉÖÂ†±„ÇíÂèñÂæó
 */
export type pathsListResponse200 = {
  data: PaginatedPathList;
  status: 200;
};

export type pathsListResponseSuccess = pathsListResponse200 & {
  headers: Headers;
};

export type pathsListResponse = pathsListResponseSuccess;

export const getPathsListUrl = (params?: PathsListParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/paths/?${stringifiedParams}`
    : `/paths/`;
};

export const pathsList = async (
  params?: PathsListParams,
  options?: RequestInit,
): Promise<pathsListResponse> => {
  return customFetch<pathsListResponse>(getPathsListUrl(params), {
    ...options,
    method: "GET",
  });
};

/**
 * ÊåáÂÆö„Åï„Çå„ÅüID„ÅÆPath„ÅÆË©≥Á¥∞ÊÉÖÂ†±„ÇíÂèñÂæóÔºàÊ®ôÈ´ò„Ç∞„É©„Éï„Éá„Éº„Çø‰ªò„ÅçÔºâ
 */
export type pathsRetrieveResponse200 = {
  data: Path;
  status: 200;
};

export type pathsRetrieveResponseSuccess = pathsRetrieveResponse200 & {
  headers: Headers;
};

export type pathsRetrieveResponse = pathsRetrieveResponseSuccess;

export const getPathsRetrieveUrl = (id: number) => {
  return `/paths/${id}/`;
};

export const pathsRetrieve = async (
  id: number,
  options?: RequestInit,
): Promise<pathsRetrieveResponse> => {
  return customFetch<pathsRetrieveResponse>(getPathsRetrieveUrl(id), {
    ...options,
    method: "GET",
  });
};

/**
 * ÊåáÂÆö„Åï„Çå„ÅüÂ¢ÉÁïå„Éú„ÉÉ„ÇØ„ÇπÂÜÖ„ÅÆË§áÊï∞„ÅÆPath„Çí‰∏ÄÊã¨ÂâäÈô§
 */
export type pathsBulkDeleteCreateResponse200 = {
  data: PathsBulkDeleteCreate200;
  status: 200;
};

export type pathsBulkDeleteCreateResponse400 = {
  data: PathsBulkDeleteCreate400;
  status: 400;
};

export type pathsBulkDeleteCreateResponseSuccess =
  pathsBulkDeleteCreateResponse200 & {
    headers: Headers;
  };
export type pathsBulkDeleteCreateResponseError =
  pathsBulkDeleteCreateResponse400 & {
    headers: Headers;
  };

export type pathsBulkDeleteCreateResponse =
  | pathsBulkDeleteCreateResponseSuccess
  | pathsBulkDeleteCreateResponseError;

export const getPathsBulkDeleteCreateUrl = (
  params: PathsBulkDeleteCreateParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/paths/bulk-delete/?${stringifiedParams}`
    : `/paths/bulk-delete/`;
};

export const pathsBulkDeleteCreate = async (
  path: NonReadonly<Path>,
  params: PathsBulkDeleteCreateParams,
  options?: RequestInit,
): Promise<pathsBulkDeleteCreateResponse> => {
  return customFetch<pathsBulkDeleteCreateResponse>(
    getPathsBulkDeleteCreateUrl(params),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(path),
    },
  );
};
